---
layout: post
title:  "MySQL InnoDB锁机制（三）"
date:   2015-01-11 22:19:16 +0800
categories: mysql
---
前面两篇文章讨论了MySQL InnoDB的锁类型与加锁方式，这次，我们来看看在不同的场景下，不同的SQL会以什么样的方式加什么类型的锁。 

在开始之前，我们先了解一下什么是聚族索引？
 
每一张InnoDB表都有且仅有一表特殊的索引，聚族索引（Clustered Index），表中的数据是直接存放在聚族索引的叶子节点页面中，这样，根据聚族索引查询就会比普通索引更快，因为少了一次IO操作。通常，聚族索引就是表的主键；如果表没有主键，那InnoDB会把第一个非空的唯一索引当作聚族索引；如果表既无主键，又无非空的唯一索引，那么InnoDB会创建一个隐藏的索引。表中的其它全部索引，都叫做第二索引（Secondary Index），第二索引中只包含自身索引列和聚族索引列的内容，所以当一个表的主键很长时，其它的索引都会受到影响。
 
为什么要先讲聚族索引呢？因为这对理解InnoDB加锁机制很重要，InnoDB加锁的对象不是返回的数据记录，而是查询这些数据时所扫描过的索引。当我们执行一个锁读（SELECT ... LOCK IN SHARE MODE或者SELECT ... FOR UPDATE）时，InnoDB不是对最终的返回结果加锁，而是对查询这些结果时所扫描的索引加锁，如果被扫描的索引不是聚族索引，那被扫描的索引所指向的聚族索引以及其它指向相同聚族索引的索引也会被加锁。由此可知，当一个锁读无法使用索引的话，InnoDB就是遍历整个表（遍历整个聚族索引），从而把整张表都锁住。
