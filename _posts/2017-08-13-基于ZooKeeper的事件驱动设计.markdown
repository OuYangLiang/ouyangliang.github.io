---
layout: post
title:  "基于ZooKeeper的事件驱动设计"
date:   2017-08-13 08:00:00 +0800
categories: 中间件
---
事件驱动架构设计在软件设计中是一种常见的方法，它有很多直观的优点。比如它的思想符合开闭原则，具有极好的可扩展性，提供更好的响应性，等等。观察者模式算得上是最简单的事件驱动设计了，但是直接使用它，也存在一些难以解决的问题。比如如何保证事件的顺序消费？在流量大的时候如何把系统的负载均衡到多个服务器？本文为大家介绍一种利用ZooKeeper实现的分布式事件驱动设计的实现。

事件驱动，首先我们要约定好什么是一个事件？事件是一个抽象的概念，用户点击某个按钮是一个事件、用户下订单是一个事件、用户支付订单是一个事件、商品发货了是一个事件，所以事件至少有两个相关的属性：

* 类型

    用于区分不同类型的事件，不同类型的事件有着不同的观注者。

* 事件的内容

    表示事件的信息，比如：谁点击了哪个按钮？谁下了订单、订单对应的商品是什么、价格多少？谁支付了订单、支付方式是什么？

很多业务场景对事件的处理顺序有严格的要求，只通过事件的类型来实现顺序的隔离在某个场景中会产生问题，比如创建订单事件，和订单变更事件是两个不同类型的事件，但它们确有先后依赖关系，订单只有先被创建出来才可能进行变更。为了解决此类问题，我们需要为事件定义一个额外的属性——分组，属于同一个分组的事件，必须按顺序处理。现在我们约定，事件的三要素：**类型、事件内容及分组**。

![整体架构]({{site.baseurl}}/pic/ZK-eventdriven/1.svg)

在系统中一共有三种角色，分别是Master服务器，Worker服务器和客户端，它们的作用分别如下：

* 客户端

    客户端用于发布事件，即把事件保存到ZooKeeper上对应的分组节点下。

* Master服务器

    Master服务器有两个主要的职责：一是监控Worker服务器，当Worker服务器发生故障下线、或者有新的Worker服务器加入集群时，重新对每个Worker进行分组分配，避免Worker单点问题同时实现负载均衡。二是当客户端发布的事件所对应的分组如果还没有分配给Worker时，将该分组分配给负载最小的Worker。

* Worker服务器

    Worker服务器用来消费事件，客户端提交的事件会由Master服务器以分组为单位分配给各个Worker。
