---
layout: post
title:  "基于ZooKeeper的事件驱动设计"
date:   2017-08-13 08:00:00 +0800
categories: 中间件
---
事件驱动在软件设计中是一种常见的方法，它有很多直观的优点。比如它的思想符合开闭原则，具有极好的可扩展性，提供更好的响应性，等等。观察者模式算得上是最简单的事件驱动设计了，但是直接使用它，也存在一些难以解决的问题。比如如何保证事件的顺序消费？在流量大的时候如何把系统的负载均衡到多个服务器？本文为大家介绍一种利用ZooKeeper实现的分布式事件驱动设计的实现。

事件驱动，首先我们要约定好什么是一个事件？事件是一个抽象的概念，用户点击某个按钮是一个事件、用户下订单是一个事件、用户支付订单是一个事件、商品发货了是一个事件，所以我们约定事件包含几个关键的属性：

* **类型**

    用于区分不同类型的事件，不同类型的事件有着不同的观注者。

* **事件的内容**

    记录事件的信息，比如：谁点击了哪个按钮？谁下了订单、订单对应的商品是什么、价格多少？谁支付了订单、支付方式是什么？

* **时间**

    表示事件发生的时间。

* **事件的分组**

    很多业务场景对事件的处理顺序有严格的要求，只通过事件的类型来实现顺序的隔离在某个场景中会产生问题，比如创建订单事件，和订单变更事件是两个不同类型的事件，但它们确有先后依赖关系，订单只有先被创建出来才可能进行变更。为了解决事件消费的顺序问题，我们需要为事件定义一个额外的属性——分组，属于同一个分组的事件，必须按顺序处理。

<br/>

好了，我们现在已经定义了一个事件的基本属性，现在我们看一下系统的总体架构设计。

![整体架构]({{site.baseurl}}/pic/ZK-eventdriven/1.svg)

在系统中一共有三类角色，分别是Master服务器，Worker服务器和客户端，它们的职责如下：

* **客户端**

    客户端用于发布事件，即把事件保存到ZooKeeper中。

* **Master服务器**

    Master服务器相当于集群中的管理员，它有两个主要的职责：一是监控Worker服务器，当Worker服务器发生故障下线、或者有新的Worker服务器加入集群时，重新对每个Worker进行任务分配，避免Worker单点问题的同时实现了系统的负载均衡。二是监控客户端提交的事件，如果事件对应的分组还没有分配给Worker的话，就将该分组分配给当前负载最小的Worker。

* **Worker服务器**

    Worker服务器用来消费事件，客户端提交的事件会由Master服务器以分组为单位分配给各个Worker。

<br/>

基于以上的构想，我们还需要对存放在ZooKeeper的信息加以一定的设计，来满足我们的需要。

![zk示例]({{site.baseurl}}/pic/ZK-eventdriven/2.svg)

在ZooKeeper中，request节点用来保存客户端提交的事件。前面我们提到，每个事件都有一个对应的分组，分组的作用是保证事件的顺序消费，所以我们不能简单的把所有的事件都放在request下面，而是把分组挂在request节点下面，事件本身挂在分组节点下面。这样，每个分组由一个Worker来顺序消费，一个worker可以处理多个分组，不同的分组可以被并行消费，取决于Master如何进行分配。这样，即解决了事件消费的顺序问题，也实现了负载的均衡。

对于Worker服务器，上线时会在workers节点下创建一个临时节点，同时监听该节点。节点的名称可以是任何能识别该Worker的标识（比如IP地址），节点的内容由Master负责更新，是一个事件分组的列表，表示分配给当前Worker处理的分组。Worker服务器在监听到自己的节点内容变化时，就读取节点内容获取分配给自己的分组，并监听request节点下对应的分组节点，当这些分组下有新的事件时，读取事件信息进行处理。

此外，我们需要一个master暂时节点来表示当前的Master服务器，成功创建master节点的成为当前的Master服务器，其它Master服务器则监听该节点，成为备用服务器。Master服务器监控request节点和workers节点。当request节点下产生了新的分组，就将该分组分配给当前负载最小的Worker服务器，即更新worker服务器的节点内容。当workers节点发生变化，说明有Worker服务器发生故障下线、或者有新的Worker服务器加入集群，这时Master服务器就重新分配所有的分组。

## 实现

---

（未完待续）
